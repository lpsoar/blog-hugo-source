---
title: 数据结构与算法之美
slug: the-beauty-of-data-structures-and-algorithms-z1cpaip
url: /post/the-beauty-of-data-structures-and-algorithms-z1cpaip.html
date: '2025-01-10 09:50:33+08:00'
lastmod: '2025-07-03 23:14:04+08:00'
toc: true
isCJKLanguage: true
---



# 数据结构与算法之美

### 数组

- 数组是一种线性表数据结构。它有一组**连续的**内存空间，来存储**同类型的数据。**

- 连续和相同类型的两个限制使它有一个杀手锏的特性：**随机访问**
- ![image](assets/image-20250110101919-003lgqy.png)

- 计算机会给每个内存单元分配一个地址，计算机通过访问地址来获取内存中的数据。当计算机需要访问数组中某个元素时，会通过寻址公式计算出元素存储的内存地址 :

  ```java
  a[i]_address = a[0]_address + i * data_type_size
  ```

- 在上图中，data_type_size 就是 4.
- 易错点：面试的时候问数组和链表的区别？

  - 不准确回答：链表适合插入，删除，时间复杂度O(1) 正确。数组适合查找，时间复杂度 O（1）表述不准确，即使是排好序的数组，使用二分查找，时间复杂度也是 O(logn)
  - 准确回答：链表适合插入，删除，时间复杂度O(1）。数组支持随机访问，根据下标随机访问的时间复杂度为O(1）

#### 低效的插入和删除

假设数组的长度为 n，现在需要将一个数据插入到数组中的第 k 个位置。为了给 k 腾出位置，k-n 的数据都需要往后面移动一位。

推算时间复杂度。最好的情况插在最后面的位置，最好时间复杂度O(1），最坏的情况插在数组最前面，最坏时间复杂度O(n）。每个位置插入数据的概率是一样的，所以平均时间复杂度 1/n * (1+2+3.....+n) = O(n)

假设数组是有序的，那么在某个位置插入数据时必须按照刚才的方法。

但如果数组是无序的，只有存储数据类似集合。那么插入数据时，可以用时间复杂度为O(1）的方法！

假设数组 a[10] 中存储了 5 个元素。现在需要把 x 插入到第 3 个位置。**我们只需要 a[5] = a[2], a[2] = x。即可！把原来的数据提取出来放到数组最后面，在当前位置插入即可。** 这个处理思想在快速排序中会用到。

‍

删除操作类似。假如要删除第 k 个位置的数据，必须把后面的数据往前移动一位。最好情况时间复杂度O(1），最坏情况时间复杂度O(2），平均情况时间复杂度O(n）

在某些特殊场景下，我们并不一定要追求数据的连续性。可以将多次删除操作集中在一次执行，提升删除效率。

a[10] 存储了 8 个元素：a,b,c,d,e,f,g,h 。现在要依次删除 a,b,c 三个元素。为了避免后面的数据被移动三次。每次的删除操作可以不真正的删除数据，**只是记录数据已经被删除。** 当没有更多空间存储时，才真正触发一次删除操作！JVM的标记清除垃圾回收机制和Go的标记清除算法的核心思想就是这个@！

#### 为什么很多编程语言数组都从0开始编号？

下标最确切的定义是“偏移量”

如上图，假如用 a 来表述数组的首地址，a[0]就是偏移为 0 的位置，就是首地址，a[k]是偏移k个data_type_size 的位置。所以计算 a[k]的地址为

```java
a[k]_address = a[0]_address + k * data_size
```

但是假入从 1 开始编号，计算公式为

```java
a[k]_address = a[0]_address + (k-1) * data_size
```

这样每次随机访问数据都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。

数组是非常基础的数据结构，所以一定要优化到极致。

最初是 C 语言设计者这么设计的，后面的语言为了减少开发者学习成本，都效仿这个设计。还是有一些数据不是从 0 计数的matlab。python甚至支持负数下标

在平时开发时，可以直接使用编程语言提供的容器类。在特别底层的开发时，数组会更合适。
